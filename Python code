# Python-Django-code


# Об'єкт який має в собі 2 методи: get - який виводить інформацію від сервера та post - який приймає інформацію від користувача

class ProductInformation(View):                                                                             # Заповнюю сторінку інформацією про продукт та формою
    def get(self, request, slug):                                                                           # Оголошую метод get який повертає мені інформацію
        form = CommentForm()                                                                                # Дістаю поля форми
        product = Product.objects.get(slug__iexact=slug)                                                    # отримую створений об'єкт з унікальним слагом
        return render(request, 'App/Product_information.html', context={'product': product, 'form': form})  # Заповнюю шаблон контентом

    def post(self, request, slug):                                                                          # Оголошую метод який приймає інформацію від користувача
        post = get_object_or_404(Product, slug=slug)                                                        # Якщо об'єкт не буде знайдений в базі, виведи http404
        product = Product.objects.get(slug__iexact=slug)                                                    # Отримуємо конкретний екземпляр класу на кожній ітерації
        products = Product.objects.all()                                                                    # Отримую всі екземпляри класу продукт
        for instans in products:
            if instans.slug == slug:                                                                        # Якщо слаг дорівнює виконуваному слагу
                id = instans.id                                                                             # Бери id екземпляру та поміти її в перемінну
        if request.method == 'POST':                                                                        # Якщо на сервер приходить інформація
            form = CommentForm(request.POST)                                                                # Заповни форму інформацією яка прийшла в словник POST
            if form.is_valid():                                                                             # Якщо дані валідні
                post = form.save(commit=False)                                                              # Притримуємо збереження для того щоб додати деякі дані з моделі
                post.product_id = id                                                                        # Вказуємо id екземпляру класу на якому знаходиться користувач
                post.date_pub = timezone.now()                                                              # Виводимо час
                post.save()                                                                                 # Зберігаємо форму
                form = CommentForm()                                                                        # Виведи порожню форму
                return render(request, 'App/Product_information.html', {'form': form, 'product': product})                                 # Якщо все ок, переводимо користувача на цю ст
        else:
            form = CommentForm()                                                                            # Задаємо формі порожні поля вводу
            return render(request, 'App/Product_information.html', context={'product': product, 'form': form})




# Об'єкт пошуку продуктів

class SearchProduct(View):
    def get(self, request):                                                                                                 # Оголошую метод get
        search_query = self.request.GET.get('search', '')                                                                   # Передаємо перемінній те, що передав користувач на сервер формою
        found_products = Product.objects.filter(Q(title__icontains=search_query) | Q(description__icontains=search_query))  # Фільтруємо об'єкти. Клас Q дає змогу організовувати пошук за двома полями об'єкту в один час
        return render(request, 'App/Results_of_search.html', context={'found_products': found_products})                    # Виводмо відфільтровані об'єкти
        
        
        
# Вдосконалений варіант пошуку продуктів
# Перевага над попереднім варіантом: дає змогу здійснювати пошук за декількома словами; переводить користувача на шаблон "нічого не знайдено". 
# Будуть виведені об'єкти в яких слова в їх полях співпали зі словами які були відправлені на сервер та оброблені класом пошуку
class MarshmallowList(View):                                                                                                    # Об'єкт в якому містяться деякі продукти
    def get(self, request):                                                                                                     # Метод get який містить в собі умовний оператор
        search_query = self.request.GET.get('search')                                                                           # Передаємо перемінній те, що передав користувач на сервер формою

        if search_query:                                                                                                        # Якщо перемінна заповнена даними
            products = Product.objects.annotate(look_for=SearchVector('title')                                                  # Аннотація дає змогу пов'язувати поля
                                                        + SearchVector('brand')                                                 # SearchVector дає з могу звернутись до декількох полів одночасно зв'язуючи їх разом
                                                        + SearchVector('description')
                                                        + SearchVector('category__category'),).filter(look_for=search_query)    # Фільтр фільтрує пов'язані поля за її аргументом
            if products:                                                                                                        # Якщо перемінна product заповнена 
                return render(request, 'App/Results_of_search.html', context={'products': products, 'search_query': search_query})  # Поверни користувача на сторінку з результатом
            else:                                                                                                                # Якщо ні
                return render(request, 'App/Not_found_search.html')                                                              # Поверни на сторінку з відсутніми результатами
        else:                                                                                                                    # Якщо ж перемінна search_query порожня
            products = Product.objects.all()                                                                                     # Помісти в перемінну всі об'єкти
            return render(request, 'App/Marshmallow_list.html', context={'products': products})                                  # Та виведи їх тут




